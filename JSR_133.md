## 1.1 锁
线程通信：同步使用管程实现  
每个对象都关联一个管程，线程通过它来执行lock或者unlock  

synchronized 需要一个对象的引用：后在给对象的管程上执行lock动作

### 代码重排

> 重单个线程的角度看，只要重排不影响该线程的执行结果，编译器就可以对该线程中的指令进行重新排序。    


1. JIT编译器和处理器可以重排
2. JVM分级存储系统可以


### 前向替换


# 3 非正式语义

1. 冲突访问
2. Happens-Before 关系

## 3.1 顺序一致性

## 3.2 final 字段


# 4. 什么是内存模型

描述该执行轨迹是否是该程序的一次合法执行    


# 5. 定义

- 共享变量/堆内存（Shared variables / Heap memory)      
静态字段以及数组元素都在存储在堆内存中。    

- 线程间的动作（Inter-thread Actions) 

是又某一线程执行，能被另一线程探测或直接影响的动作  

write   
read    
lock    锁定的管程  
unlock  要解锁的管程    

- 程序顺序 ( Program Order) 
- 线程内语义 Intra-thread semantics 
单线程程序的标准语义    

- 同步动作（Synchronization Actions) 

- 同步顺序 Synchronization Order 
一次执行过程中的所有同步动作上的全序关系

- Happends-Before与Synchronizes-With边缘    
x和y在同一个线程的动作，且顺序x在y之前 x Happends-before y


1. 某个管程m上的解锁动作synchronizes-with 所有后续在m上的
2. 对volatile 变量v的写操作synchronizeds-with 所有后续任意线程对v的读操作
3. 用于启动一个线程的动作synchronizeds-with该新启动线程中的第一个动作


# 6. java 内存模型的近似模型



## 6.1 顺序一致的内存模型

所有动作以全序的顺序发生，与程序顺序一致；      
而且，每个对变量v的读操作r都将看到写操作w写人v的值，只要：
- 执行顺序上w在r之前，且    
- 执行顺序上不存在这样一个w', w 在w' 之前且w' 在r之前   

## 6.2 Happens-Before 内存模型

> 简单的内存模型

- 在所有的同步动作上都有一个全序，即同步顺序。该顺序与程序顺序以及锁的互斥一致
- 同步到你这包括相配对的动作间的synchronizes-with边缘
- synchronizes-with边缘的传递闭包与


