# 序言

- 提供各种实用的设计规则 

基础知识：2-5       
结构化并运用程序：6-9   
活跃性、性能和测试：10-12   
高级主题:13-16 

# 第1章 简介


## 1.1 并发简史

- 串行编程模型的优势在于其直观性和简单性    

## 1.2 线程的优势

1. 发挥多处理器的强大能力
2. 建模的简单性
3. 异步事件的简化处理
4. 响应更快的用户界面



## 1.3 线程带来的风险

1. 安全性问题
2. 活跃性问题 
死锁 饥饿 活锁
3. 性能问题

## 1.4 线程无处不在




# 第一部分 基础知识

# 第2章 线程安全性

- 要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的和可变的状态的访问。  
- 一个对象是否需要时线程安全的，取决于它是否被多线程访问 

多线程可变的变量没有合适的同步解决  
1. 不在线程之间共享该状态变量
2. 将状态变量修改为不可变的变量
3. 在访问状态变量时使用同步

-  当设计线程安全的类是，良好的面向对象技术、不可修改性，以及明晰的不变性规范都能起到一定的帮助作用
- 最好也只是当性能测试结果和应用需求告诉你必须提高性能，以及测量结果表明这种优化在实际环境中确实能带来性能提升是，才进行优化。


## 2.1 什么是线程安全性

当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就城这个类是线程安全的。


- 无状态对象一定是线程安全的。（无状态：不包含任何域，也不包含任何对其他类中域的引用）
如Servlet 

## 2.2 原子性

竞争条件：由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况。


### 2.2.1 竞争条件

先检查后执行


- 在实践情况中，应尽可能地使用现有的线程安全对象来管理类的状态。与非线程安全对象相比，判断线程安全对象的可能状态及其状态转换情况要更容易，从而更容易维护和验证线程安全性。


## 2.3 加锁机制

- 要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量

### 2.3.1 内置锁
目的：支持原子性    
同步代码块：    
1. 一个作为锁的对象引用，   
2. 作为由这个锁保护的代码块     

```
synchronized(lock){
}
// 块和锁
```
1.  横跨整个方法体的同步代码块，锁就是方法调用所在的对象
2. 静态的方法一Class对象作为锁

定义：内置锁 | 监视锁 ： 每个对象都可以用做一个实现同步的锁。也是互斥锁 最多只有一个线程持有这种锁

### 2.3.2 重入

1. 同线程可以重入已有锁的方法
2. 锁操以线程为丽都，不是调用


## 2.4 用锁来保护状态
每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。

## 2.5 活跃性和性能
缩小同步代码块的作用范围，保证并性能。


# 第3章 对象的共享
synchronized 原子性&临界区&内存可见性


## 3.1 可见性


### 3.1.1 失效数据
多线程情况下写入和读取没有同步   ：最低安全性

### 3.1.2 非原子的64位操作

非volatile类型的64位数值变量：long double 64位读写2步操作

### 3.1.3 加锁与可见性
加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程多必须在同一个锁上同步。

### 3.1.4 Volatile变量
弱同步机制，确保将变量的更新操作通知到其他线程。    
编译器与运行时都会注意到这个变量时共享的，因此不会将改变量上的操作与其他内存操作一起重新排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方。
I: 仅当volatile变量能简化代码的实现以及同步策略的验证是，才一个使用他们。

I: 加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。

使用规则：
- 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值
- 该变量不会与其他状态变量一起纳入不变性条件中
- 在访问变量时不需要加锁

## 3.2 发布与逸出

发布publish使对象能够在当前作用域之外代码中使用。   

逸出escape 当每个不应该发布的对象被发布是   

封装能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得更难    


