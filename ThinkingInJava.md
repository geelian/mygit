# 第1章 对象导论
“我们之所以将自然界分解，组织成各种概念，并按其含义分类，主要是因为我们是整个口语交流社会共同遵守的协定的参与者，这个协定以语言的形式固定下来...除非赞成这个协议中规定的有关语言信息的组织和分类，否则我们根本无法交谈。”  --Benjamin LeeWhorf

面向对象程序设计

## 抽象过程
机器《--抽象-- 汇编 《-- 抽象--- 命令式 

## 面向接口编程
所以类的父类Object

## 封装 继承 多态 复用
封装：隐藏的具体实现
继承：替代原则
多态：默认动态绑定
复用：组合优于继承

## GC
自动控制对象的生命周期

## 异常处理
java内置异常处理


# 第2章 一切都是对象
“如果我们说另一种不同的语言，那么我们就会发觉一个有些不同的世界。” --Luduing Wittgerstein
- 所以的对象都是间接引用
## 必须由你创建对象
inew
### 存储地方
- 寄存器
- 堆栈
- 堆
Time存储清理 > 堆栈
- 常量存储
- 非RAM存储
序列化
### 基本类型
自动装箱
### 数组
会检查越界

## static 
1. 可以用this访问
2. 会自动初始化

## System.out 
系统相关
## 注释
javadoc -d /home/ file.java


# 第3章  操作符
- \>\>\> 零扩展

# 第4章 控制执行流程
就像有知觉的生物一样，程序必须在执行过程中控制它的世界，并做出选择。在java中你要使用执行控制语句来做出选择。
## return 
- 返回值
- 退出
## 臭名昭著的goto
```
label1: //一定要在outer-iteration之上，中间不能有语句
outer-iteration{
	inner-iteratio{
		continue; //(1)
		continue label1; // (2)
		back; //(3)
		break label1; // (4)
	}
}
```
(1).一般continue会退回最内层循环的开头，并继续执行
(2).带标签的continue会到达标签的位置，并重新进入紧接在那个标签后面的循环
(3).一般的break会中断并跳出当前循环
(4).带标签的break会中断并跳出标签所指的循环

## switch
()只能放整数类型，可以考虑用enum

# 第5章 初始化与清理
随着计算机革命的发展，"不安全"的编程方式已逐渐成为编程代价高昂的主因之一。

## 用构造器确保初始化
默认构造器：不接受任何参数的构造器，没有构造函数时自动生成。
## this关键字
- “发生消息给对象”，f(this)被隐藏在第一位中，消息发生给this
- this.pick(),不写this保证高级语言特性
- static函数没有带this

## 清理：终结处理和垃圾回收
1. 对象可能不被垃圾回收
2. 垃圾回收并不等于“析构”
3. 垃圾回收只与内存有关
## 初始化顺序
1）static 变量/块 一次 
1. 当首次生成这个类的一个对象时
2. 或者首次访问属于那个类的静态数据成员时
_ 也就是第一次加载.class文件时static所以成员被初始化一次 _
2）非static初始化 n次
每次new时都是初始化
3）构造函数初始化 n次
## 可变参数列表
public static void f(Object... args){
}
## 枚举类型
public enum Spiciness{
	NOT,MILD,MEDIUM,HOT,FLAMING
}

# 第6章 访问控制权限
"如何把变动的事物与保持不变的事物区分开来"
权限大小顺序：public > protected > 包访问权限 > private
1. 通过继承不能得到包的继承
protedcted 基类的创建者会希望有某个特定成员，把对它的访问权限赋予派生类而不是所有类
2. protected具有包访问权限
3. 默认构造器位public类型
## 类的访问权限
1). 每个文件（编译单元）都只能有一个public类
2). public类的名称必须完全与含有该文件（编译单元)的文件名相匹配
3). 文件（编译单元) 可不带


# 第7章 复用类
复用代码是java众多引入注明的功能之一，但要想成为极具更明显的语言，仅仅能够辅助代码并对之加以改变还是不够的，它还必须能做更多的事情
"is-a是一个" 继承 
"has-a有一个" 组合
## 组合
只需在新的类中产生现在类的对象
## 继承
按照现有类的类型来创建新类
### 初始化顺序
1. 自动从基类开始初始化 
加载类所有的static --\>父类中变量--\>父类构造函数--\>子类中变量--\>子类构造函数
2. 构造函数，调研父类方法super()必须放在第一位，保证上面的顺序 
### 重载
子类可以和父类的方法重载 // ps(C++不支持)
@Override

### 向上转型 ： 具有多态性
新类是现有类的一种类型

## final关键性
### 数据 
作用
1. 一个永不改变的编译是常量
2. 一个在运行是被初始化的值，而你不希望它被改变
空白final：必须在构造器中初始化
final参数：不能改变 
### 方法 
1. 把方法锁定，以防如何继承类修改它的意义（不能继承）
2. 效率（内联）
final&private 类中所有的private方法都隐式地指定为是final的
### 类 
不能被继承

# 第8章　多态
三大特效：多态　继承　数据抽象
目的：消除类型之间的耦合关系
别名：动态绑定、后期绑定、运行时绑定
## 向上转型
对象既可以作为它自己本身的类型使用，也可以作为它的基类型使用。
## 转机
绑定：一个方法调用同一个方法主体关联起来被称作绑定。
前期绑定：程序执行前进行绑定，明确知道用什么方法
后期/动态/运行时绑定：运行时根据对象的类型进行绑定－－>不管怎样都必须在对象中安置某种“类型信息”
> java中除了static方法和final方法(private方法属于final方法)之外，其他方法都是后期绑定。

# 第9章 接口
接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法
抽象类：普通的类与接口之间的一种中庸之道
## 抽象类和抽象方法
抽象类：本身并不完整 abstract class{}
- 不能实例化
- 可以有实例化方法
抽象方法： abstract void f(); 
- 不完整的
- 只有声明没有方法体
- 如果一个类有>=1 个抽象方法，必须声明为抽象的
- 子类非抽象类必须实现抽象方法
## 接口 interface 
implements 实现
1. 一个完全的抽象类
2. 允许人们通过创建一个能够被向上转型为多种基类的类型，来实现某种类似多重继变种的特性
3. 只有声明
4. 内默认都是public，不能用private和protected，interface默认还是包权限
## 完全解耦
策略模式：创建一个能够根据所传递的参数对象的不同而具有不同行为的方法
适配器模式：将接受你所拥有的接口
## 多继承
- 如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类
- 如果知道某事物应该成为一个基类，那么第一选择应该是使它成为一个接口
- 接口可以继承其他接口，不能继承其他类

# 第10章 内部类
可以将一个类的定义放在另一个类的定义内部，这就是内部类 
* 内部类与组合是完全不同的概念 *
```
public class Parcel1{
	class Contents{
	}
}
```
访问外部类：
OutterClassName.InnerClassName  
目的：
> 每个内部类都能独立的继承自一个实现，所以无论外围类是否已经继承了某个实现，对与内部类都没有影响。

> 设计模式总是将变化的事物与保持不变的事物分离

## 链接到外部类
内部类对象可以访问他的外围对象的所有成员，内部类还有外围了的所有元素的访问权
原理
> 当某个外围类的对象创建了一个内部类对象时，此内部类必定会秘密的捕获一个指向那个外围类对象的引用。
> 然后，在你访问此外围类的成员时，就是用那个引用来选择外围类对象的成员
> 有外部类才能有外部类(非static内部类) 
内-》外： OutterClassName.this 
外部建立内部类： OutterClassName.InnerClassName = outterClass.new InnerClassName(); // 必须有外部类outterClass

## 嵌套类（静态内部类static）
* 不需要外部类对象的引用 *
* 普通内部类不能有static数据和static字段但是嵌套类可以
要求：
1. 要创建嵌套类对象，并不需要外围类的对象
2. 不能从嵌套类的对象中访问非静态的外围类对象。
### 接口内部的嵌套类
```
public interface ClassInInterface{
	class Test implementes ClassInInterface{}
}
```
空格


## 在方法和作用域内的内部类
目的
1. 实现了某类型的接口，于是可以创建并返回对其的引用
2. 要决绝一个复杂问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。

## 匿名内部类
内部a类的简化
```
public new Contents()
	return new Contents(){};
}
```
注意：
1. 如果定义一个匿名内部类，并希望它使用一个在其外部的定义的对象，那么编译器会要求其参数引用是final的
2. 匿名内部类即可以扩展类，也可以实现接口，但是太难同时兼备，而且如果是实现接口，也只能实现一个接口
不使理由：需要不止一个内部类对象

## 继承内部类
```
class WithInner{
	class Inner{}
}

class Inner2 extends WithInner.Inner{
	Inner2(WithInner wf){
		wf.super();
	}
}
```
1. 必须带他的外部类到构造函数中 
2. 内部类不能被覆盖


## 闭包和回调
闭包：是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域：内部类是面向对象的闭包

## 内部类标识符
LoclaInnerClass$1.class 匿名的
LoclaInnerClass$LoalCounter.calss
